<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>AgarM Classic</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#f2f2f2;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    canvas{display:block;touch-action:none}

    #hud{
      position:fixed;left:10px;top:10px;z-index:30;
      background:rgba(255,255,255,.88);
      padding:8px 10px;border-radius:12px;
      border:1px solid rgba(0,0,0,.08);
      font-size:13px;line-height:1.25;
      max-width: 420px;
    }
    #hud b{font-weight:900}
    #hud .small{opacity:.7;font-size:12px;margin-top:4px}

    #lb{
      position:fixed;right:10px;top:10px;z-index:30;
      background:rgba(255,255,255,.88);
      padding:8px 10px;border-radius:12px;
      border:1px solid rgba(0,0,0,.08);
      font-size:13px;line-height:1.25;
      width:170px;
    }
    #lb b{font-weight:900}

    /* Joystick */
    #joyBase{
      position:fixed;left:16px;bottom:16px;width:140px;height:140px;border-radius:50%;
      background:rgba(0,0,0,.06);
      border:1px solid rgba(0,0,0,.12);
      z-index:40;
      touch-action:none;
    }
    #joyStick{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:62px;height:62px;border-radius:50%;
      background:rgba(0,0,0,.12);
      border:1px solid rgba(0,0,0,.16);
    }

    /* Buttons */
    .btn{
      position:fixed;right:16px;z-index:40;border-radius:18px;
      background:rgba(255,255,255,.88);
      border:1px solid rgba(0,0,0,.12);
      color:#111;font-weight:900;
      display:flex;align-items:center;justify-content:center;
      user-select:none;-webkit-user-select:none;
      touch-action:none;
      box-shadow: 0 4px 16px rgba(0,0,0,.08);
    }
    #splitBtn{bottom:22px;width:92px;height:92px;font-size:16px}
    #ejectBtn{bottom:126px;width:70px;height:70px;font-size:13px}
    #boostBtn{bottom:208px;width:70px;height:70px;font-size:13px}

    /* Settings */
    #settingsBtn{
      position:fixed;left:10px;bottom:170px;z-index:50;
      width:44px;height:44px;border-radius:14px;
      background:rgba(255,255,255,.88);
      border:1px solid rgba(0,0,0,.12);
      display:flex;align-items:center;justify-content:center;
      color:#111;font-size:20px;user-select:none;
      box-shadow: 0 4px 16px rgba(0,0,0,.08);
    }
    #settingsPanel{
      position:fixed;left:10px;bottom:220px;z-index:50;
      width:260px;padding:12px;border-radius:16px;
      background:rgba(255,255,255,.94);color:#111;
      display:none;border:1px solid rgba(0,0,0,.12);
      box-shadow: 0 6px 22px rgba(0,0,0,.12);
    }
    #settingsPanel .row{display:flex;gap:10px;align-items:center;margin:8px 0}
    #settingsPanel .title{font-weight:900;font-size:16px;margin-bottom:6px}
    #settingsPanel .row span{flex:1;font-size:13px;opacity:.95}
    #settingsPanel input[type="range"]{flex:1.25}
    #settingsPanel select{flex:1.25;padding:6px;border-radius:10px;border:1px solid rgba(0,0,0,.15)}
    #settingsPanel .hint{opacity:.7;font-size:12px;line-height:1.25}

    /* Minimap */
    #mini{
      position:fixed;right:10px;bottom:10px;z-index:30;
      width:140px;height:140px;border-radius:12px;
      background:rgba(255,255,255,.88);
      border:1px solid rgba(0,0,0,.08);
      overflow:hidden;
    }
  </style>
</head>
<body>

  <div id="hud">
    <div><b>AgarM Classic</b> ü´ß</div>
    <div>Mass: <span id="mass">10</span> | Cells: <span id="cells">1</span></div>
    <div class="small">Joystick/mouse: hareket ‚Ä¢ SPLIT ‚Ä¢ EJECT ‚Ä¢ BOOST</div>
  </div>

  <div id="lb">
    <b>Leaderboard</b>
    <div id="lbList" style="margin-top:6px;"></div>
  </div>

  <canvas id="mini"></canvas>

  <div id="settingsBtn">‚öôÔ∏è</div>
  <div id="settingsPanel">
    <div class="row title">Ayarlar</div>

    <div class="row">
      <span>FPS</span>
      <select id="fpsCap">
        <option value="30">30</option>
        <option value="60">60</option>
        <option value="120">120</option>
      </select>
    </div>

    <div class="row">
      <span>Grafik</span>
      <input id="renderScale" type="range" min="0.6" max="1" step="0.05" value="1">
      <span id="renderScaleVal">1.00</span>
    </div>

    <div class="row">
      <span>Ses</span>
      <input id="sound" type="range" min="0" max="1" step="0.01" value="0.6">
      <span id="soundVal">0.60</span>
    </div>

    <div class="row hint">D√º≈ü√ºk telefon: Grafik 0.70 + FPS 60 ‚úÖ</div>
  </div>

  <div id="joyBase"><div id="joyStick"></div></div>

  <div id="splitBtn" class="btn">SPLIT</div>
  <div id="ejectBtn" class="btn">EJECT</div>
  <div id="boostBtn" class="btn">BOOST</div>

<script>
/* =========================
   AGARM CLASSIC (2D)
   GitHub Pages ‚úÖ
   ========================= */

const SETTINGS_KEY = "AGARM_CLASSIC_SETTINGS_V1";
let Settings = { fpsCap: 60, renderScale: 1.0, sound: 0.6 };
try{
  const raw = localStorage.getItem(SETTINGS_KEY);
  if(raw) Settings = { ...Settings, ...JSON.parse(raw) };
}catch(e){}
function saveSettings(){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(Settings)); }

/* ---------- UI refs ---------- */
const massEl = document.getElementById("mass");
const cellsEl = document.getElementById("cells");
const lbListEl = document.getElementById("lbList");

const settingsBtn = document.getElementById("settingsBtn");
const settingsPanel = document.getElementById("settingsPanel");
const fpsCapEl = document.getElementById("fpsCap");
const renderScaleEl = document.getElementById("renderScale");
const renderScaleValEl = document.getElementById("renderScaleVal");
const soundEl = document.getElementById("sound");
const soundValEl = document.getElementById("soundVal");

fpsCapEl.value = String(Settings.fpsCap);
renderScaleEl.value = String(Settings.renderScale);
renderScaleValEl.textContent = Number(Settings.renderScale).toFixed(2);
soundEl.value = String(Settings.sound);
soundValEl.textContent = Number(Settings.sound).toFixed(2);

settingsBtn.onclick = () => settingsPanel.style.display = (settingsPanel.style.display==="none"?"block":"none");
fpsCapEl.onchange = () => { Settings.fpsCap = parseInt(fpsCapEl.value,10); saveSettings(); };
renderScaleEl.oninput = () => {
  Settings.renderScale = parseFloat(renderScaleEl.value);
  renderScaleValEl.textContent = Settings.renderScale.toFixed(2);
  resize();
  saveSettings();
};
soundEl.oninput = () => {
  Settings.sound = parseFloat(soundEl.value);
  soundValEl.textContent = Settings.sound.toFixed(2);
  saveSettings();
};

/* ---------- Canvas ---------- */
const canvas = document.createElement("canvas");
document.body.insertBefore(canvas, document.body.firstChild);
const ctx = canvas.getContext("2d", { alpha:false });

let PR = 1;

function resize(){
  const scale = Settings.renderScale;
  PR = Math.min(devicePixelRatio, 2) * scale;
  canvas.width  = Math.floor(innerWidth * PR);
  canvas.height = Math.floor(innerHeight * PR);
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  ctx.setTransform(PR,0,0,PR,0,0);
}
addEventListener("resize", resize);
resize();

/* ---------- Minimap ---------- */
const mini = document.getElementById("mini");
const mctx = mini.getContext("2d");

/* ---------- Utils ---------- */
const TAU = Math.PI * 2;
function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function d2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx + dy*dy; }
function massToRadius(m){ return 10 + Math.sqrt(m)*4.0; } // classic look

/* ---------- World ---------- */
const WORLD = 3000;
const PELLET_COUNT = 1200;
const pellets = [];
for(let i=0;i<PELLET_COUNT;i++){
  pellets.push({
    x: rand(-WORLD,WORLD),
    y: rand(-WORLD,WORLD),
    m: rand(0.8, 2.2),
    c: `hsl(${Math.floor(rand(0,360))} 85% 55%)`
  });
}

const ejects = []; // ejected mass blobs

/* ---------- Simple sound (beep) ---------- */
let audioCtx=null, gainNode=null;
function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  gainNode = audioCtx.createGain();
  gainNode.gain.value = Settings.sound;
  gainNode.connect(audioCtx.destination);
}
function sfx(freq=420, dur=0.08){
  if(!audioCtx || !gainNode) return;
  gainNode.gain.value = Settings.sound;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type="triangle";
  o.frequency.value = freq;
  g.gain.value = 0.0001;
  o.connect(g); g.connect(gainNode);
  o.start();
  g.gain.exponentialRampToValueAtTime(0.08, audioCtx.currentTime+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+dur);
  o.stop(audioCtx.currentTime+dur+0.01);
}

/* ---------- Player (multiple cells) ---------- */
const player = {
  name: "You",
  color: "#2b7cff",
  cells: [
    { x:0, y:0, vx:0, vy:0, mass: 10, splitCD:0 }
  ]
};

function totalMass(entity){
  let t=0;
  for(const c of entity.cells) t += c.mass;
  return t;
}

/* ---------- Bots ---------- */
const bots = [];
function spawnBot(i){
  const hue = Math.floor(rand(0,360));
  const bot = {
    name: "Bot"+(i+1),
    color: `hsl(${hue} 85% 45%)`,
    cells: [
      { x:rand(-WORLD,WORLD), y:rand(-WORLD,WORLD), vx:0, vy:0, mass:rand(8,55), splitCD:0 }
    ],
    aiAng: rand(0,TAU),
    aiT: rand(0,2)
  };
  bots.push(bot);
}
for(let i=0;i<24;i++) spawnBot(i);

/* ---------- Input (joystick + mouse) ---------- */
const joyBase = document.getElementById("joyBase");
const joyStick = document.getElementById("joyStick");
let joyActive=false, joyId=null;
let joyCenter={x:0,y:0};
let joyVec={x:0,y:0};

function setJoy(dx,dy){
  const max=48;
  const d=Math.hypot(dx,dy);
  let nx=dx, ny=dy;
  if(d>max){ nx=dx/d*max; ny=dy/d*max; }
  joyStick.style.transform=`translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;
  joyVec.x = nx/max;
  joyVec.y = ny/max;
}
function joyEnd(){
  joyActive=false; joyId=null;
  joyVec.x=0; joyVec.y=0;
  joyStick.style.transform="translate(-50%,-50%)";
}

joyBase.addEventListener("touchstart",(e)=>{
  e.preventDefault();
  initAudio();
  const t=e.changedTouches[0];
  joyActive=true; joyId=t.identifier;
  const r=joyBase.getBoundingClientRect();
  joyCenter.x = r.left + r.width/2;
  joyCenter.y = r.top  + r.height/2;
  setJoy(t.clientX-joyCenter.x, t.clientY-joyCenter.y);
},{passive:false});
joyBase.addEventListener("touchmove",(e)=>{
  if(!joyActive) return;
  e.preventDefault();
  for(const t of e.changedTouches){
    if(t.identifier===joyId){
      setJoy(t.clientX-joyCenter.x, t.clientY-joyCenter.y);
      break;
    }
  }
},{passive:false});
joyBase.addEventListener("touchend",(e)=>{ e.preventDefault(); joyEnd(); },{passive:false});
joyBase.addEventListener("touchcancel",(e)=>{ e.preventDefault(); joyEnd(); },{passive:false});

/* Mouse for desktop */
let mouseVec = {x:0,y:0};
addEventListener("mousemove",(e)=>{
  const cx = innerWidth/2, cy = innerHeight/2;
  const dx = e.clientX - cx;
  const dy = e.clientY - cy;
  const d = Math.hypot(dx,dy) || 1;
  mouseVec.x = dx/d;
  mouseVec.y = dy/d;
});

/* ---------- Buttons ---------- */
const splitBtn = document.getElementById("splitBtn");
const ejectBtn = document.getElementById("ejectBtn");
const boostBtn = document.getElementById("boostBtn");
let boosting = false;

splitBtn.addEventListener("touchstart",(e)=>{ e.preventDefault(); initAudio(); split(player); },{passive:false});
ejectBtn.addEventListener("touchstart",(e)=>{ e.preventDefault(); initAudio(); eject(player); },{passive:false});
boostBtn.addEventListener("touchstart",(e)=>{ e.preventDefault(); boosting=true; },{passive:false});
boostBtn.addEventListener("touchend",(e)=>{ e.preventDefault(); boosting=false; },{passive:false});
boostBtn.addEventListener("touchcancel",(e)=>{ e.preventDefault(); boosting=false; },{passive:false});

/* Keyboard (optional) */
addEventListener("keydown",(e)=>{
  if(e.code==="Space") split(player);
  if(e.key==="w" || e.key==="W") eject(player);
});

/* ---------- Core mechanics ---------- */
function split(entity){
  // split the biggest cell (classic)
  let idx = 0;
  for(let i=1;i<entity.cells.length;i++) if(entity.cells[i].mass > entity.cells[idx].mass) idx=i;
  const c = entity.cells[idx];
  if(!c || c.mass < 18 || entity.cells.length >= 16 || c.splitCD > 0) return;

  c.splitCD = 1.2;

  const newMass = c.mass * 0.50;
  c.mass *= 0.50;

  const dir = getMoveDir();
  const r = massToRadius(c.mass);
  const sp = 900; // launch speed

  entity.cells.push({
    x: c.x + dir.x*(r*2),
    y: c.y + dir.y*(r*2),
    vx: dir.x*sp,
    vy: dir.y*sp,
    mass: newMass,
    splitCD: 1.2
  });

  sfx(260, 0.09);
}

function eject(entity){
  // eject a tiny mass blob from biggest cell
  let idx = 0;
  for(let i=1;i<entity.cells.length;i++) if(entity.cells[i].mass > entity.cells[idx].mass) idx=i;
  const c = entity.cells[idx];
  if(!c || c.mass < 14) return;

  c.mass -= 1.2;

  const dir = getMoveDir();
  const sp = 1000;

  ejects.push({
    x: c.x + dir.x*20,
    y: c.y + dir.y*20,
    vx: dir.x*sp,
    vy: dir.y*sp,
    mass: 1.2,
    c: entity.color,
    life: 3.2
  });

  sfx(520, 0.06);
}

function getMoveDir(){
  // prefer joystick on mobile; else mouse
  const jmag = Math.hypot(joyVec.x, joyVec.y);
  if(jmag > 0.02) return {x:joyVec.x, y:joyVec.y};
  return {x:mouseVec.x, y:mouseVec.y};
}

/* ---------- Camera ---------- */
const cam = { x:0, y:0, zoom:1 };

function updateCam(dt){
  // camera follows the average position
  let ax=0, ay=0;
  for(const c of player.cells){ ax+=c.x; ay+=c.y; }
  ax /= player.cells.length;
  ay /= player.cells.length;

  cam.x += (ax - cam.x) * clamp(dt*6,0,1);
  cam.y += (ay - cam.y) * clamp(dt*6,0,1);

  // zoom based on total mass
  const tm = totalMass(player);
  const target = clamp(1.15 - Math.sqrt(tm)/120, 0.42, 1.10);
  cam.zoom += (target - cam.zoom) * clamp(dt*3.5,0,1);
}

/* ---------- Movement + physics ---------- */
function moveCells(entity, dt){
  const dir = (entity === player) ? getMoveDir() : null;
  const boost = (entity === player && boosting) ? 1.40 : 1.0;

  for(const c of entity.cells){
    // decay split impulse
    c.vx *= Math.pow(0.05, dt);
    c.vy *= Math.pow(0.05, dt);

    // speed depends on mass (classic)
    const sp = (520 / Math.sqrt(c.mass)) * boost;

    // AI or Player control
    let mx=0, my=0;
    if(entity === player){
      mx = dir.x; my = dir.y;
    }else{
      // bots drift towards a target direction
      mx = Math.cos(entity.aiAng);
      my = Math.sin(entity.aiAng);
    }

    c.x += (mx*sp + c.vx) * dt;
    c.y += (my*sp + c.vy) * dt;

    // bounds
    c.x = clamp(c.x, -WORLD, WORLD);
    c.y = clamp(c.y, -WORLD, WORLD);

    c.splitCD = Math.max(0, c.splitCD - dt);
  }

  // remerge (very simple): if close enough and no splitCD, combine
  if(entity.cells.length > 1){
    for(let i=entity.cells.length-1;i>0;i--){
      const a = entity.cells[i];
      for(let j=0;j<i;j++){
        const b = entity.cells[j];
        if(a.splitCD>0 || b.splitCD>0) continue;
        const ar = massToRadius(a.mass);
        const br = massToRadius(b.mass);
        if(d2(a.x,a.y,b.x,b.y) < (Math.max(ar,br)*0.55)**2){
          b.mass += a.mass;
          entity.cells.splice(i,1);
          break;
        }
      }
    }
  }
}

/* ---------- Eating rules ---------- */
function tryEatPellets(entity){
  for(const c of entity.cells){
    const r = massToRadius(c.mass);
    const eatR2 = (r*0.95)*(r*0.95);
    for(let i=pellets.length-1;i>=0;i--){
      const p = pellets[i];
      if(d2(c.x,c.y,p.x,p.y) < eatR2){
        c.mass += p.m*0.55;
        pellets.splice(i,1);
        // respawn pellet
        pellets.push({ x:rand(-WORLD,WORLD), y:rand(-WORLD,WORLD), m:rand(0.8,2.2), c:`hsl(${Math.floor(rand(0,360))} 85% 55%)`});
      }
    }
  }
}

function tryEatEjects(entity){
  for(const c of entity.cells){
    const r = massToRadius(c.mass);
    const eatR2 = (r*0.90)*(r*0.90);
    for(let i=ejects.length-1;i>=0;i--){
      const e = ejects[i];
      if(d2(c.x,c.y,e.x,e.y) < eatR2){
        c.mass += e.mass*0.90;
        ejects.splice(i,1);
      }
    }
  }
}

function cellCanEat(big, small){
  // classic: must be ~10% bigger
  return big.mass > small.mass * 1.12;
}

function eatBetween(A, B){
  // A eats B if possible
  for(const ac of A.cells){
    const ar = massToRadius(ac.mass);
    for(let bi=B.cells.length-1; bi>=0; bi--){
      const bc = B.cells[bi];
      const br = massToRadius(bc.mass);

      // only eat if radius big enough + distance inside
      if(!cellCanEat(ac, bc)) continue;

      if(d2(ac.x,ac.y,bc.x,bc.y) < (ar - br*0.25)**2){
        ac.mass += bc.mass * 0.85;
        B.cells.splice(bi,1);
      }
    }
  }
}

/* ---------- Bot AI ---------- */
function updateBotsAI(dt){
  for(const b of bots){
    b.aiT -= dt;
    if(b.aiT <= 0){
      b.aiT = rand(0.6, 1.6);
      b.aiAng = rand(0, TAU);

      // if player is close and bigger, run away
      const pm = totalMass(player);
      const bm = totalMass(b);
      const pc = player.cells[0];
      const bc = b.cells[0];
      const dist = Math.hypot(pc.x-bc.x, pc.y-bc.y);

      if(pm > bm*1.25 && dist < 900){
        const ax = bc.x - pc.x;
        const ay = bc.y - pc.y;
        b.aiAng = Math.atan2(ay, ax);
      }
      // if bot is bigger, chase player a bit
      if(bm > pm*1.35 && dist < 900){
        const ax = pc.x - bc.x;
        const ay = pc.y - bc.y;
        b.aiAng = Math.atan2(ay, ax);
      }
    }
  }
}

/* ---------- Update world ---------- */
function update(dt){
  updateBotsAI(dt);

  moveCells(player, dt);
  for(const b of bots) moveCells(b, dt);

  // move ejects
  for(let i=ejects.length-1;i>=0;i--){
    const e = ejects[i];
    e.life -= dt;
    e.x += e.vx*dt;
    e.y += e.vy*dt;
    e.vx *= Math.pow(0.02, dt);
    e.vy *= Math.pow(0.02, dt);
    if(e.life <= 0) ejects.splice(i,1);
  }

  tryEatPellets(player);
  tryEatEjects(player);
  for(const b of bots){
    tryEatPellets(b);
    tryEatEjects(b);
  }

  // eating player/bots
  for(const b of bots){
    eatBetween(player, b);
    eatBetween(b, player);
  }

  // respawn dead bots
  for(let i=bots.length-1;i>=0;i--){
    if(bots[i].cells.length === 0){
      bots.splice(i,1);
      spawnBot(Math.floor(rand(1,999)));
    }
  }

  updateCam(dt);

  // UI
  massEl.textContent = Math.floor(totalMass(player));
  cellsEl.textContent = String(player.cells.length);
}

/* ---------- Render ---------- */
function worldToScreen(x,y){
  const sx = (x - cam.x) * cam.zoom + innerWidth/2;
  const sy = (y - cam.y) * cam.zoom + innerHeight/2;
  return {sx,sy};
}

function drawBackground(){
  // classic grid
  ctx.fillStyle = "#f2f2f2";
  ctx.fillRect(0,0,innerWidth,innerHeight);

  const step = 80 * cam.zoom;
  ctx.strokeStyle = "rgba(0,0,0,0.06)";
  ctx.lineWidth = 1;

  const left = cam.x - innerWidth/(2*cam.zoom);
  const right= cam.x + innerWidth/(2*cam.zoom);
  const top  = cam.y - innerHeight/(2*cam.zoom);
  const bottom=cam.y + innerHeight/(2*cam.zoom);

  ctx.beginPath();
  for(let x=Math.floor(left/80)*80; x<right; x+=80){
    const p1 = worldToScreen(x, top);
    const p2 = worldToScreen(x, bottom);
    ctx.moveTo(p1.sx, p1.sy);
    ctx.lineTo(p2.sx, p2.sy);
  }
  for(let y=Math.floor(top/80)*80; y<bottom; y+=80){
    const p1 = worldToScreen(left, y);
    const p2 = worldToScreen(right, y);
    ctx.moveTo(p1.sx, p1.sy);
    ctx.lineTo(p2.sx, p2.sy);
  }
  ctx.stroke();

  // world border
  ctx.strokeStyle = "rgba(0,0,0,0.12)";
  ctx.lineWidth = 4;
  const tl = worldToScreen(-WORLD, -WORLD);
  const br = worldToScreen(WORLD, WORLD);
  ctx.strokeRect(tl.sx, tl.sy, br.sx-tl.sx, br.sy-tl.sy);
}

function drawPellets(){
  for(const p of pellets){
    const s = worldToScreen(p.x, p.y);
    const r = (2.6 + p.m*1.1) * cam.zoom;
    if(s.sx<-20||s.sy<-20||s.sx>innerWidth+20||s.sy>innerHeight+20) continue;
    ctx.fillStyle = p.c;
    ctx.beginPath();
    ctx.arc(s.sx, s.sy, r, 0, TAU);
    ctx.fill();
  }
}

function drawEjects(){
  for(const e of ejects){
    const s = worldToScreen(e.x,e.y);
    const r = massToRadius(e.mass) * 0.55 * cam.zoom;
    ctx.fillStyle = e.c;
    ctx.beginPath();
    ctx.arc(s.sx, s.sy, r, 0, TAU);
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.10)";
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

function drawEntity(entity){
  for(const c of entity.cells){
    const s = worldToScreen(c.x,c.y);
    const r = massToRadius(c.mass) * cam.zoom;

    // cell
    ctx.fillStyle = entity.color;
    ctx.beginPath();
    ctx.arc(s.sx, s.sy, r, 0, TAU);
    ctx.fill();

    // outline
    ctx.strokeStyle = "rgba(0,0,0,0.15)";
    ctx.lineWidth = Math.max(2, r*0.06);
    ctx.stroke();

    // name + mass (classic)
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.font = `bold ${Math.max(12, r*0.35)}px system-ui`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(entity.name, s.sx, s.sy - r*0.05);

    ctx.font = `bold ${Math.max(11, r*0.28)}px system-ui`;
    ctx.fillText(Math.floor(c.mass), s.sx, s.sy + r*0.28);
  }
}

function draw(){
  drawBackground();
  drawPellets();
  drawEjects();
  for(const b of bots) drawEntity(b);
  drawEntity(player);
  drawMinimap();
  drawLeaderboard();
}

function drawMinimap(){
  const w = mini.width, h = mini.height;
  mctx.clearRect(0,0,w,h);
  mctx.fillStyle = "rgba(255,255,255,0.88)";
  mctx.fillRect(0,0,w,h);

  // border
  mctx.strokeStyle = "rgba(0,0,0,0.18)";
  mctx.lineWidth = 2;
  mctx.strokeRect(1,1,w-2,h-2);

  // scale world -> map
  const sx = w/(WORLD*2);
  const sy = h/(WORLD*2);
  function map(x,y){
    return { x:(x+WORLD)*sx, y:(y+WORLD)*sy };
  }

  // bots dots
  for(const b of bots){
    const c = b.cells[0];
    if(!c) continue;
    const p = map(c.x,c.y);
    mctx.fillStyle = "rgba(0,0,0,0.35)";
    mctx.beginPath();
    mctx.arc(p.x,p.y,2.4,0,TAU);
    mctx.fill();
  }

  // player dot
  const pc = player.cells[0];
  const pp = map(pc.x,pc.y);
  mctx.fillStyle = "#2b7cff";
  mctx.beginPath();
  mctx.arc(pp.x,pp.y,3.2,0,TAU);
  mctx.fill();
}

function drawLeaderboard(){
  const all = [{name:player.name, m:totalMass(player), me:true}];
  for(const b of bots) all.push({name:b.name, m:totalMass(b), me:false});
  all.sort((a,b)=>b.m-a.m);

  let html = "";
  for(let i=0;i<Math.min(10, all.length);i++){
    const it = all[i];
    html += `<div style="display:flex;justify-content:space-between;${it.me?'font-weight:900':''}">
      <span>${i+1}. ${it.name}</span><span>${Math.floor(it.m)}</span></div>`;
  }
  lbListEl.innerHTML = html;
}

/* ---------- Main loop (fps cap) ---------- */
let last = performance.now();
let acc = 0;

function loop(now){
  requestAnimationFrame(loop);
  const dt = Math.min(0.05, (now-last)/1000);
  last = now;

  acc += dt;
  const step = 1 / (Settings.fpsCap || 60);

  if(acc >= step){
    update(acc);
    acc = 0;
  }
  draw();
}
requestAnimationFrame(loop);

// prevent iOS page scroll
document.body.addEventListener("touchmove", (e)=>e.preventDefault(), {passive:false});
</script>

</body>
</html>